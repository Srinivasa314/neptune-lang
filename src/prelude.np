const {ecall, generateStackTrace} = _getModule('vm')

export class Error {
    construct(message) {
        this.message = message
        this.stack = generateStackTrace(1)
    }
    toString() {
        return '\(this.getClass().name()): \(this.message)\n\(this.stack)'
    }
}

export class OverflowError extends Error {
    construct(message) {
        super.construct(message)
    }
}

export class TypeError extends Error {
    construct(message) {
        super.construct(message)
    }
}

export class ArgumentError extends Error {
    construct(message) {
        super.construct(message)
    }
}

export class PropertyError extends Error {
    construct(message) {
        super.construct(message)
    }
}

export class NoMethodError extends Error {
    construct(message) {
        super.construct(message)
    }
}

export class NoModuleVariableError extends Error {
    construct(message) {
        super.construct(message)
    }
}

export class IndexError extends Error {
    construct(message) {
        super.construct(message)
    }
}

export class KeyError extends Error {
    construct(message) {
        super.construct(message)
    }
}

export class CompileError extends Error {
    construct(message) {
        super.construct(message)
    }
}

export class EFuncError extends Error{
    construct(message) {
        super.construct(message)
    }
}

export class ModuleNotFoundError extends Error{
    construct(message) {
        super.construct(message)
    }
}

export fun import(moduleName) {
    if moduleName.getClass() !== String {
        throw new TypeError('The first argument must be a String, not \(moduleName.getClass().name())')
    }
    let module = _getModule(moduleName)
    if module {
        return module
    }else {
        moduleName = ecall(@resolveModule,{callerModule: _getCallerModule(), moduleName: moduleName})
        module = _getModule(moduleName)
        if module {
            return module
        } else {
            let source = ecall(@fetchModule, moduleName)
            ecall(@compile, {moduleName: moduleName, eval: false, source:source})()
            return _getModule(moduleName)
        }
    }
}

export fun eval(source) {
    if source.getClass() !== String {
        throw new TypeError('The first argument must be a String, not \(source.getClass().name())')
    }
    return ecall(@compile, {moduleName: _getCallerModule(), eval: true, source: source})()
}

export class Iterator {
    each(f) {
        for elem in this {
            f(elem)
        }
    }

    all(f) {
        for elem in this {
            if !f(elem) {
                return false
            }
        }
        return true
    }

    any(f) {
        for elem in this {
            if f(elem) {
                return true
            }
        }
        return false
    }

    map(f) {
        return new IteratorMap(this, f)
    }

    filter(f) {
        return new IteratorFilter(this, f)
    }

    collect() {
        let a = []
        for elem in this {
            a.push(elem)
        }
        return a
    }

    count() {
        let count = 0
        for _ in this {
            count+=1
        }
        return count
    }

    reduce(f, initial) {
        for elem in this {
            initial = f(initial, elem)
        }
        return initial
    }
}

class IteratorMap extends Iterator {
    construct(iter, f) {
        this.iter = iter
        this.f = f
    }

    hasNext() {
        return this.iter.hasNext()
    }

    next() {
        return this.f(this.iter.next())
    }
}

class IteratorFilter extends Iterator {
    construct(iter, f) {
        this.iter = iter
        this.f = f
        this.nextObject = null
        this.nextObjectSet = false
    }

    hasNext() {
        return this.nextObjectSet or this.setNextObject()
    }

    next() {
        if !this.nextObjectSet and !this.setNextObject(){
            return null
        }
        this.nextObjectSet = false
        return this.nextObject
    }

    setNextObject(){
        while this.iter.hasNext(){
            let obj = this.iter.next()
            if this.f(obj){
                this.nextObject = obj
                this.nextObjectSet = true
                return true
            }
        }
        return false
    }
}

_extendClass(ArrayIterator, Iterator)
_extendClass(MapIterator, Iterator)
_extendClass(StringIterator, Iterator)
_extendClass(Range, Iterator)
